# -*- coding: utf-8 -*-
"""KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bXxcesA-Ie5IO2HjzpXHXuFXicSWIIF9
"""

import pandas as pd
import numpy as np

"""# Load Data"""

url =  "data_arrhythmia.csv"
df = pd.read_csv(url, delimiter=';')

"""# Data Explorations"""

# Membaca beberapa baris pertama dari data
df.head()

# Membaca beberap baris terakhir dari data
df.tail()

# Menampilkan unique value pada kolom diagnosis
df['diagnosis'].unique()

# Menampilkan metadata dari data
df.info()

# Menampilkan summary statistik dari data
df.describe()

# Menampilkan jumlah baris dan kolom pada dataframe
df.shape

"""# Preprocessing"""

#Mengubah semua isi kolom menjadi numerik dan mengubah "?" menjadi NaN
df_columns = df.iloc[:, 0:281]
df = df_columns.apply(lambda x: pd.to_numeric(x, errors='coerce'))

# Melakukan folding pada data
fold1 = (df.iloc[0:150].reset_index(drop=True), df.iloc[150:300].reset_index(drop=True))
fold2 = (df.iloc[150:300].reset_index(drop=True), pd.concat([df.iloc[0:150], df.iloc[300:452]]).reset_index(drop=True))
fold3 = (df.iloc[300:452].reset_index(drop=True), df.iloc[0:452].reset_index(drop=True))
# Menampilkan data fold2 untuk training sebanyak 302 baris
test, train = fold2
print(train)

# Assign fitur dan kelas
# Menghapus kolom diagnosis(karena akan kita gunakan sebagai class)
X = df.drop('diagnosis', axis=1)
# diagnosis sebagai kelas
Y = df.diagnosis
df

"""#Min-Max Normalization"""

# Melakukan normalisasi data dengan min-max normalization
def norm(df):
  df = (df - df.min()) / (df.max() - df.min())
  return df

# Melakukan normalisasi untuk data fitur
X = norm(X)

X

"""# KNN Model"""

# Menghitung jarak menggunakan euclidean distance
def euclidean(x1, x2):
    return np.sqrt(np.sum((x1-x2)**2))

# Euclidean distance dari data baris pertama dan kedua
euclidean(X.iloc[0],X.iloc[1])

# Training KNN
def knn(X_train, y_train, X_test, k): # k sebagai banyaknya neighbors yang ditentukan
  dist = []
  # Menghitung distance dari data training dan data testing
  for row in range(X_train.shape[0]):
    dist.append(euclidean(X_train.iloc[row],X_test))
  # Menambahkan data distance pada data
  data = X_train.copy()
  data['Dist'] = dist
  # Menambahkan class pada data
  data['Class'] = y_train
  # Mengurutkan data berdasarkan distance
  data = data.sort_values(by='Dist').reset_index(drop=True)
  # Mengambil label kelas yang paling sering muncul diantara k-NN 
  y_pred = data.iloc[:k].Class.mode()
  return y_pred[0]

"""# Evaluation """

# Menghitung akurasi dari output berdasarkan label kelas
def acc(y_pred, y_true):
  true = 0
  for i in range(len(y_pred)):
    if y_pred[i] == y_true[i]:
      true += 1
  return true/len(y_pred)

# Evaluasi model dengan menggunakan data fold
def evaluate(fold, k):
  test, train = fold
  X_train, Y_train = train.drop('diagnosis', axis=1), train.diagnosis
  X_test, Y_test = test.drop('diagnosis', axis=1), test.diagnosis
  X_train = norm(X_train)
  X_test = norm(X_test)
  y_preds = []
  for row in range(X_test.shape[0]):
    y_preds.append(knn(X_train,Y_train,X_test.iloc[row],k))
  return (acc(y_preds, Y_test))

#Main Program
k = 5
accs = []
folds = [fold1, fold2, fold3]
for i in range(len(folds)):
  accs.append(evaluate(folds[i], k))
print(f'Menggunakan k : {k}, dengan rata-rata akurasi : {sum(accs)/3}')